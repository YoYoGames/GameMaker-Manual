<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Accessors</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining the different Accessors" />
  <meta name="rh-index-keywords" content="Accessors" />
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Accessors</h1>
  <p>O <span class="notranslate">GameMaker Language</span> (<span class="notranslate">GML</span>) também lhe permite acessar certas <a href="../GML_Reference/Data_Structures/Data_Structures.htm">Estruturas de Dados</a> e <a href="Arrays.htm">Arrays</a> através do uso de expressões lógicas chamadas <b>acessores</b>. Isto é estruturado de forma semelhante a quando se trabalha normalmente com um array, apenas usamos um <em>símbolo identificador</em> antes do primeiro argumento para dizer ao <span data-keyref="GameMaker Name">GameMaker</span> que você está trabalhando em uma estrutura de dados (previamente criada) ou no array literal.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">Listas DS [| ]</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot">A sintaxe das <a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">listas DS</a> é:</p>
    <p class="code">list_index[| index]</p>
    <p class="dropspot">Assim, quando você tiver usado <span class="inline">ds_list_create()</span> para criar sua lista, você usaria o índice da lista (que você armazenou em uma variável) para referenciá-lo, sendo o valor &quot;índice&quot; a posição na lista a ser definida ou adicionada. Por exemplo, o seguinte código cria uma lista e depois adiciona 10 entradas, definindo cada entrada como número aleatório de 0 a 9:</p>
    <p class="code">ds = ds_list_create();<br />
      var index = 0;<br />
      repeat(10)<br />
      {<br />
          ds[| index++] = irandom(9);<br />
      }</p>
    <p class="dropspot">Observe que se você estiver usando uma expressão para adicionar uma referência a um índice que já tem um valor, o valor anterior será substituído em vez de ter um índice adicional adicionado à lista. Para adicionar mais entradas, você precisaria saber o tamanho da ds_list e adicioná-los ao final. Vale notar também que você pode definir um índice de lista <i>maior</i> do que o tamanho da lista que está sendo referenciada, e isto definirá esse valor, expandindo a lista ao mesmo tempo e inicializando todas as posições da lista até o índice dado como 0.</p>
    <p class="dropspot">Uma vez criada a estrutura de sua lista e preenchida com dados, para obter valores da lista, você teria algo parecido:</p>
    <p class="code">value = ds[| 5];</p>
    <p class="dropspot">O acima receberá o valor da posição 5 (o sexto índice, já que as listas começam em 0) e o armazenará em uma variável. Se você fornecer uma posição que esteja fora do tamanho da lista, então o valor <span class="inline">undefined</span> será devolvido, o que você pode verificar se a função <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">DS Maps [? ]</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot">A sintaxe dos <a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">mapas DS</a> é:</p>
    <p class="code">map_index[? key]</p>
    <p class="dropspot">Depois de criar seu mapa com <span class="inline">ds_map_create()</span>, você usaria o índice do mapa que você armazenou em uma variável para referenciá-lo, sendo o valor &quot;chave&quot; a chave do mapa a ser definida ou obtida. Por exemplo, o seguinte código cria um mapa e depois adiciona algumas entradas a ele usando esta sintaxe:</p>
    <p class="code">ds = ds_map_create();<br />
      ds[? &quot;Name&quot;] = &quot;Hamish&quot;;<br />
      ds[? &quot;Company&quot;] = &quot;MacSeweeny Games&quot;;<br />
      ds[? &quot;Game&quot;] = &quot;Catch The Haggis&quot;;</p>
    <p class="dropspot">Observe que se o mapa já contém o mesmo valor chave que você está tentando adicionar, ele não criará uma chave duplicada com o novo valor, mas sim o valor anterior será substituído.</p>
    <p class="dropspot">Uma vez criada sua estrutura de mapa e preenchida com dados, para obter valores de uma chave de mapa específica, você teria algo assim:</p>
    <p class="code">value = ds[? &quot;Name&quot;];</p>
    <p class="dropspot">O valor acima será obtido da chave &quot;Name&quot; e armazenado em uma variável, mas esteja ciente de que se a chave dada não existir no mapa DS, então o valor retornado será <span class="inline">undefined</span>. Isto pode ser verificado para o uso da função <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Grades DS [# ]</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot">A sintaxe da <a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">grade DS</a> é:</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot">Depois de criar sua grade com a função <span class="inline">ds_grid_create()</span>, você usaria o índice da grade que você armazenou em uma variável para referenciá-la, sendo &quot;xpos&quot; e &quot;ypos&quot; a posição dentro da grade para obter ou definir um valor. Por exemplo, o seguinte código cria uma grade, limpa-a para 0 e depois adiciona algumas entradas a ela:</p>
    <p class="code">ds = ds_grid_create();<br />
      ds_grid_clear(ds, 0);<br />
      var gw = ds_grid_width(ds) - 1;<br />
      var gh = ds_grid_height(ds) - 1;<br />
      repeat(10)<br />
      {<br />
          var xx = irandom(gw);<br />
          var yy = irandom(gh);<br />
          if (ds[# xx, yy] == 0)<br />
          {<br />
              ds[# xx, yy] = 1;<br />
          }<br />
      }</p>
    <p class="dropspot">Uma vez criada sua estrutura de grade e preenchida com dados, para obter valores de uma posição específica da grade, você teria algo parecido:</p>
    <p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p>
    <p class="dropspot">O acima receberá o valor do ds_grid dado com base na posição do mouse (dividido pela largura da &quot;célula&quot; no site <span class="notranslate">room</span> para obter a localização correta). Se você fornecer uma posição que esteja fora dos limites da grade, então o valor <span class="inline">undefined</span> será retornado, o que você pode verificar para usar a função <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">Arrays [@ ]</a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">Este acessor só é usado quando a <a href="../../Settings/Game_Options.htm">opção Copiar na Gravação</a> está ativada.</p>
    <p class="dropspot">As arrays também têm seus próprios acessores que funcionam de forma semelhante aos listados acima para estruturas de dados. Entretanto, os acessores de array têm uma propriedade interessante e que é permitir que você modifique um array a partir de uma <a href="Script_Functions.htm">função de script</a> ou <a href="Method_Variables.htm"><span class="notranslate">method</span></a> sem ter que copiá-lo. Quando você passa um array para uma função, ele é <strong>passado por referência</strong>, o que significa que o array em si não está sendo dado no <span class="notranslate">script</span>, mas está sendo simplesmente referenciado para obter os dados. Normalmente, se você precisar alterar o array, ele seria <em>copiado </em>para o <span class="notranslate">script</span> e então você precisaria passar de volta (devolver) o array copiado para que o array original fosse atualizado. Isto pode ter custos altos de processamento, e assim você pode usar o acessor em seu lugar, pois isso mudará o array original <em>diretamente </em>sem a necessidade de que ele seja copiado. Você pode ver como isto funciona nos exemplos abaixo.</p>
    <p class="dropspot">A sintaxe das arrays, utilizando o acessor <span class="inline">@</span>, é:</p>
    <p class="code">array[@ i]</p>
    <p class="dropspot">Após ter criado seu array em uma instância, você pode então passá-lo para um <span class="notranslate">script</span> por referência e usar o acessor <span class="inline">@</span> para mudá-lo diretamente. Por exemplo, você criaria a array e chamaria a diversão assim:</p>
    <p class="code">array[99] = 0;<br />
      array_populate(array);</p>
    <p class="dropspot">A função em si teria algo assim:</p>
    <p class="code">function array_populate(_array)<br />
      {<br />
          var a = _array; var i = 0; repeat(25)<br />
          {<br />
              i = irandom(99);<br />
              while (a[i] != 0)<br />
              {<br />
                  i = irandom(99);<br />
              }<br />
              a[@ i] = 100;<br />
          }<br />
      }</p>
    <p class="dropspot">Tudo o que esta função está fazendo é selecionar 25 posições aleatórias na matriz e definir o valor da posição da matriz escolhida para 100.</p>
    <p class="dropspot">Naturalmente, o acessor <span class="inline">@</span> não é necessário quando a opção <strong>Copy on Write</strong> está desativada.</p>
    <p class="note"><span class="note">NOTA</span> Você não pode usar o acessor de array <span class="inline">@</span> ao trabalhar com o array <span class="inline">argument[n]</span> em funções de script.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Estruturas [$ ]</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span>A sintaxe para <a href="Structs.htm">as estruturas</a> é</span></p>
    <p class="code">struct[$ &quot;name&quot;]</p>
    <p class="dropspot">Este acessório é essencialmente um invólucro para as funções <span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> e <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>, e você o usaria muito parecido com o acessório para um mapa DS. Por exemplo, se você tiver criado um <span class="notranslate">struct</span> e quiser recuperar um valor de uma variável chamada &quot;my_health&quot;, então você o faria:</span></p>
    <p class="code">var _hp = struct[$ &quot;my_health&quot;];</p>
    <p class="dropspot">Como você pode ver, você não fornece a variável em si, mas sim um <em>fio</em> com a variável. Observe que se o <span class="notranslate">struct</span> não tiver uma variável com o nome dado, então o acessor retornará <span class="inline">undefined</span> como o valor.</p>
    <p class="dropspot">Para definir uma variável em um <span class="notranslate">struct</span>, você faria o seguinte</p>
    <p class="code">struct[$ &quot;my_score&quot;] = 100;</p>
    <p class="dropspot">Como na obtenção de um valor, você fornece o nome da variável a ser definida como um <span class="notranslate">string</span>, e ele será definido para o valor dado. Se o nome da variável utilizada não existir no <span class="notranslate">struct</span>, então ela será criada e definida para o valor dado.</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Uma característica importante dos acessores é o fato de que eles podem ser <i>acorrentados</i> juntos. Isto significa que se você tiver várias estruturas de dados e/ou matrizes aninhadas, não há mais a necessidade de usar uma variedade de funções para obter acesso a um valor que está profundamente dentro da estrutura aninhada. Por exemplo, digamos que você tenha uma matriz, e cada item da matriz é uma lista DS, como esta:</p>
  <p class="code">array = array_create(3);<br />
    for (var i = 0; i &lt; 3; ++i;)<br />
    {<br />
        array[i] = ds_list_create();<br />
        switch(i)<br />
        {<br />
            case 0:<br />
                with (obj_Wall) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 1:<br />
                with (obj_Door) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 2:<br />
                with (obj_Chest) ds_list_add(array[i], id);<br />
            break;<br />
        }<br />
    }
  </p>
  <p>No código acima, criamos uma matriz de 3 itens e atribuímos uma lista DS a cada um deles, e depois preenchemos as diferentes listas com as identificações de instância de vários <span class="notranslate">objects</span> no jogo. Agora, para acessar um ID em uma das listas, podemos fazer o seguinte:</p>
  <p class="code">var _list = array[0];<br />
    var _id = ds_list_find_value(_list, 0);</p>
  <p>Entretanto, você pode fazer a mesma coisa usando acessores encadeados de uma maneira muito mais limpa e que usa menos código:</p>
  <p class="code">var _id = array[0][| 0];</p>
  <p>Você pode encadear vários acessores desta forma e eles podem ser de vários tipos para ter acesso às informações armazenadas em cada parte da estrutura aninhada. Aqui estão mais alguns exemplos:</p>
  <p class="code">// Access a grid that has been added to a list that is part of a map:<br />
    var _a = data[? &quot;lists&quot;][| 0][# 0, 0];<br />
    <br />
    // Access an array nested in a list from a script and modify it:<br />
    data[| 0][@ 10] = 100;<br />
    <br />
    // Access a map nested in a grid nested in a list nested in an array:<br />
    data[0][| 10][# 3, 4][? &quot;key&quot;] = &quot;hello world&quot;;
  </p>
  <p>O uso de acessores encadeados para coisas não só significa que você pode escrever um código mais compacto, mas também permitirá que você use a iteração (por exemplo, usando um <a href="Language_Features/for.htm"><span class="inline">for</span></a> loop) e outras técnicas para acessar seus dados de uma maneira mais limpa e intuitiva.</p>
  <p>Vale notar que ao utilizar os acessores desta forma, você deve sempre usar o acessor <span class="inline">@</span> para arrays, caso contrário, você estará adicionando despesas extras a qualquer ação que esteja sendo realizada. Como mencionado acima, por padrão as arrays são passadas por referência para as funções e então usar o comportamento &quot;copy on write&quot; quando modificado. Entretanto, se o array for parte de uma cadeia, então o item anterior na cadeia será atualizado com o array copiado e o &quot;original&quot; será excluído. Por exemplo, fazer algo como isto:</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][0] = 200;
  </p>
  <p>alcança os mesmos resultados que o mesmo resultado:</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][@ 0] = 200;
  </p>
  <p>No entanto, o segundo exemplo é melhor, pois funciona sem a sobrecarga desnecessária de copiar primeiro toda a matriz.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Voltar: <a href="GML_Overview.htm">Visão geral da GML</a></div>
        <div style="float:right">A seguir: <a data-xref="{title}" href="Language_Features.htm">Características lingüísticas</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Todos os direitos reservados</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->
</body>
</html>